DynamoDB is a fully-managed, NoSQL database provided by Amazon Web Services.

When to use DynamoDB?
  - Hyper-scale applications
  - Hyper-ephemeral compute (aka serverless) DynamoDB is perfect for applications that are serverless.

Core Concepts in DynamoDB
  - Table
    It is a grouping of records that conceptually belong together.
  - Item
    An item is a single record in a DynamoDB table. It is comparable to a row in a relational database or a document in MongoDB.
  - Attributes
    A DynamoDB item is made up of attributes, which are typed data values holding information about the element.
    When you write an item to DynamoDB, each attribute is given a specific type. There are ten different data types in DynamoDB. It’s
    helpful to split them into three categories:
      - Scalars: Scalars represent a single, simple value, such as a username(string) or an age(number). There are 5 scalar types:
                 string, number, binary, boolean and null.
      - Complex: Complex types are the most flexible kind of attribute, as they represent groupings with arbitrary nested attributes.
                 There are two complex types: lists and maps.
      - Sets: Sets are a powerful compound type that represents multiple, unique values. They are similar to sets in your favorite programming language. 
              Each element in a set must be the same type, and there are three set types: string sets, number sets, and binary sets.
  - Primary Keys: When creating a DynamoDB table, you must declare a primary key for your table. Each item in your table must include the primary key.
  - Secondary indexes: Secondary indexes allow you to reshape your data into another format for querying, so you can add additional 
                           access patterns to your data.

PRIMARY KEYS
Types of primary keys
  - Simple primary keys: which consist of a single element called a partition key.
  - Composite primary keys: which consist of two elements, called partition key and sort key.

The type of primary key you choose will depend on your access patterns.
A simple primary key allows you to fetch only a single item at a time.
Composite primary keys, on the other hand, enable a "fetch many" access pattern. With a composite primary key, you can use the
Query API to grab all items with the same partition key.

SECONDARY INDEXES
Types of secondary indexes
  - Local secondary indexes
  - Global secondary indexes
  
A local secondary index uses the same partition key as your tables primary key but a different sort key.
With global secondary index, you can choose any attributes you want for your partition key and your sort key.

Item Collection
An item collection refers to a group of items that share the same partition key in either the base table or a secondary index.
DynamoDB partitions your data across a number of nodes in a way that allows for consistent performance as you scale. However, all items with the same
partition key will be kept on the same storage node.

-------------------------------------------------------------------------------------------------------------------------------------------------------
DynamoDB Stream
A DynamoDB stream is an ordered flow of information about changes to items in a DynamoDB table. 
When you enable a stream on a table, DynamoDB captures information about every modification to data items in the table.
The combination of DynamoDB Streams with serverless compute with AWS Lambda gives you a fully-managed
system to react to database changes.

Time-to-live(TTL)
TTL's allow you to have DynamoDB automatically delete items on a per-item basis. This is a great option for storing short-term 
data in DynamoDB.

Partitions
Partitions are the core storage units underlying your DynamoDB table.
We noted before that DynamoDB is built for infinite scale, and it does that by sharding your data across multiple server
instances. Each item collection will be in a particular partition, and this will enable fast queries on multiple items.

Consistency
Each partition in DynamoDB is made up of 3 nodes.
1 primary node and 2 secondary nodes.
When you do a write operation
  - DynamoDB request router takes the partition key from the request
  - hashes the partition key and finds the right partition
  - writes to the primary node in the partition
  - responds to the client saying the wite operation is complete
  - asynchronously replicates the item from the primary to secondary nodes.
The reason for having secondary nodes
  - Provide fault-tolerance in case the primary node goes down
  - These secondary nodes can serve read requests to alleviate pressure on the primary node

** Problem **
Because writes are asynchronously replicated from the primary to secondary nodes, the secondary might be a little behind the primary node.

Two consistency options available with DynamoDB
  - Strong consistency: any item you read from DynamoDB will reflect all writes that occurred prior to the read being executed.
  - Eventual consistency(default): Its possible the item(s) you read will not reflect all prior writes.
  
There are two times you need to think about consistency with DynamoDB
  - Whenever you are reading data from the base table, you can choose your consistency level. By default its eventually-consistent read.
  - You should think about consistency when choosing your secondary index type. 

------------------------------------------------------------------------------------------------------------------------------------------------
DynamoDB Limits
  - Item size limits
    A single DynamoDB item is limited to 400KB of data.
  - Query and Scan request size limits
    Query and Scan, the two "fetch many" API actions will read a maximum of 1MB of data from your table.
  - Partition throughput limits
    A single partition can have a maximum of 3000 Read Capacity Units or 1000 Write Capacity Units.
    Thus you will need to be doing 3000 reads per second for a given partition key to hit these limits.
  - Item collection limits
    An item collection refers to all items with a given partition key. A single item collection cannot be larger than 10GB.
  
------------------------------------------------------------------------------------------------------------------------------------------------
Overloading Keys
One unique quirk of modeling with DynamoDB is that you will often include different types of entities in a single table.

              Primary Key                       Attributes
Partition Key: PK    Sort Key: SK         OrgName        Subscription Level
ORG#INFOSYS          ORG#INFOSYS          Infosys        Enterprise
                                          UserName       Role
ORG#INFOSYS          USER#ANTONY          Antony C       Employee
ORG#INFOSYS          USER#AASHISH         Aashish A      Employee

In the above table, we have 2 different types of entities, Users and Organisations.
Organisations and Users have a different set of attributes.
Look at the way the partition key and the sort key are maintained.
This concept of using generic names for your primary keys and using different values depending on the type of item is known as
overloading your keys.

================================================================================================================================================
DynamoDB API's

API's split into 3 categories
1: Item-based actions - operating on specific items
2: Queries - operating on an item collection
3: Scans - operating on the whole table

----------------------------------------------------------------------------------------------------------------------------------
Item-based actions
There are 4 core API actions for item-based actions
  - GetItem: used for reading a single item from a table
  - PutItem: used for writing an item to a table. This can completely overwrite an existing item with the same key, if any.
  - UpdateItem: used for updating an item in a table. This can create a new item if it doesn’t previously exist, or it can add,
                remove, or alter properties on an existing item.
  - DeleteItem: used for deleting an item from a table.
  
3 rules around item-based actions
  - Full primary key must be specified in your request
  - All actions to alter data - writes, updates or delete must use an item-based action.
  - All item-based actions must be performed on your main table, not a secondary index.

2 sub-categories of single-item API
  - Batch actions
  - Transaction actions
These categories are used for reading and writing multiple DynamoDB items in a single request. While these operate on
multiple items at once, I still classify them as item-based actions because you must specify the exact items on which you want to
operate.

Batch action: your reads or writes can succeed or fail independently. The failure of one write
              won’t affect the other writes in the batch.
Transaction action: all of your reads or writes will succeed or fail together. The failure of a single
                    write in your transaction will cause the other writes to be rolled back.
  
-----------------------------------------------------------------------------------------------------------------------------------
Query API

The Query API action lets you retrive multiple items with the same partition key.

A Query operation using the AWS JavaScript SDK

const inputParams = {
    TableName: "test_MoviesAndActors",
    KeyConditionExpression: "#actor = :actor AND #movie BETWEEN :a AND :m",
    ExpressionAttributeNames: {
      "#actor": "Actor",
      "#movie": "Movie",
    },
    ExpressionAttributeValues: marshall({
      ":actor": "Tom Hanks",
      ":a": "A",
      ":m": "M",
    }),
  };
  
const data = await dbClient.send(new QueryCommand(inputParams));

----------------------------------------------------------------------------------------------------------------------------------
Scan API
A Scan will grab everything in a table.
The times you may consider using the scan operation.
  - When you have a small table
  - When you're exporting all data from your table to a different system
  - In exceptional situations, where you have specifically modeled a sparse secondary index in a way that expects a scan.

DON'T USE SCANS
----------------------------------------------------------------------------------------------------------------------------------
How DynamoDB enforces efficiency?
DynamoDB uses partitions, or small storage nodes of about 10GB, to shard your data across multiple machines. The
sharding is done on the basis of the partition key. Thus, if the DynamoDB request router is given the partition key for an item, it
can do an O(1) lookup in a hash table to find the exact node or set of nodes where that item resides.
This is why all the single-item actions and the Query action require a partition key.

===================================================================================================================================
Expression Attribute names and values

In the query operation example above in the KeyConditionExpression we notice two placeholders
Ones that start with # and other placeholders that start with :
The ones that start with a color(:) are expression attribute values. Look at the ExpressionAttributeValues property in our request.

Why can’t we just write our attribute values directly into the expression?
Remember that each attribute value in DynamoDB has a type. DynamoDB does not infer this type—you must explicitly provide it
when you make a request.

The placeholders that start with # are expression attribute names.
These are used to specify the name of the attribute you are evaluating in your request.

Why can’t we just write our attribute name directly into the expression?
Well you can write the attribute name directly into your expression. That said, there are a few times when the use of
ExpressionAttributeNames is required. The most common reason is if your attribute name is a reserved word in DynamoDB. There
are 573 reserved words in DynamoDB, and many of them will conflict with normal attribute names.

-----------------------------------------------------------------------------------------------------------------------------------
Don't use an ORM
Object-relational mappers (ORMs) are popular tools when using relational databases in your application code.
There is an exceptional library called DynamoDB Toolbox. DynamoDB Toolbox is explicitly not an ORM. However, it does help you define entity
types in your application and map those to your DynamoDB table.

-----------------------------------------------------------------------------------------------------------------------------------
Understand the optional properties on individual requests

1: ConsistentRead
   By default, reads from DynamoDB are eventually consistent, meaning that the reads will
   likely, but not definitely, reflect all write operations that have happened before the given read operation.
   To get a strongly-consistent read, you need to set ConsistentRead=True in your API call. 
   The ConsistentRead property is available on four operations:
   - GetItem
   - BatchGetItem
   - Query
   - Scan
   
   Opting into a strongly-consistent read consumes more read request units than using an eventually-consistent read.
   If you are using a local secondary index, you may opt into strong consistency by passing ConsistentRead=True. 
   All reads from a global secondary index are eventually consistent.
  
2: ScanIndexForward
   This property is available only on the Query operation, and it controls which way you are reading results from the sort key.
   Lets say our table has a partition key as the sensor id and the sort key is the timestamp.
   DynamoDb orders its sort key in ascending order. Imagine your sensor reported data every minute. After a single day
   of operation, your sensor would have 1440 readings. However, to find the most recent 20 readings, you would need to page through
   all 1440 readings until you got to the end. That would consume a lot of read capacity!
   
   The ScanIndexForward property allows you to flip the direction in which DynamoDB will read your sort key. If you set
   ScanIndexForward=False, then DynamoDB will read your sort key in descending order.
   
3: ReturnValues
   It will be helpful to receive additional information about existing or updated item from DynamoDb after certail api call finishes.
   The API's with th ReturnValues property are 
   - PutItem
   - UpdateItem
   - DeleteItem
   - TransactWriteItem
   
   There are a few different available options for the ReturnValues property:
   - NONE: Return no attributes from the item. This is the default setting.
   - ALL_OLD: Return all the attributes from the item as it looked before the operation was applied.
   - UPDATED_OLD: For any attributes updated in the operation, return the attributes before the operation was applied.
   - ALL_NEW: Return all the attributes from the item as it looks after the operation is applied.
   - UPDATED_NEW: For any attributes updated in the operation, return the attributes after the operation is applied.
   
4: ReturnConsumedCapacity
   
