DynamoDB is a fully-managed, NoSQL database provided by Amazon Web Services.

When to use DynamoDB?
  - Hyper-scale applications
  - Hyper-ephemeral compute (aka serverless) DynamoDB is perfect for applications that are serverless.

Core Concepts in DynamoDB
  - Table
    It is a grouping of records that conceptually belong together.
  - Item
    An item is a single record in a DynamoDB table. It is comparable to a row in a relational database or a document in MongoDB.
  - Attributes
    A DynamoDB item is made up of attributes, which are typed data values holding information about the element.
    When you write an item to DynamoDB, each attribute is given a specific type. There are ten different data types in DynamoDB. It’s
    helpful to split them into three categories:
      - Scalars: Scalars represent a single, simple value, such as a username(string) or an age(number). There are 5 scalar types:
                 string, number, binary, boolean and null.
      - Complex: Complex types are the most flexible kind of attribute, as they represent groupings with arbitrary nested attributes.
                 There are two complex types: lists and maps.
      - Sets: Sets are a powerful compound type that represents multiple, unique values. They are similar to sets in your favorite programming language. 
              Each element in a set must be the same type, and there are three set types: string sets, number sets, and binary sets.
  - Primary Keys: When creating a DynamoDB table, you must declare a primary key for your table. Each item in your table must include the primary key.
  - Secondary indexes: Secondary indexes allow you to reshape your data into another format for querying, so you can add additional 
                           access patterns to your data.

PRIMARY KEYS
Types of primary keys
  - Simple primary keys: which consist of a single element called a partition key.
  - Composite primary keys: which consist of two elements, called partition key and sort key.

The type of primary key you choose will depend on your access patterns.
A simple primary key allows you to fetch only a single item at a time.
Composite primary keys, on the other hand, enable a "fetch many" access pattern. With a composite primary key, you can use the
Query API to grab all items with the same partition key.

SECONDARY INDEXES
Types of secondary indexes
  - Local secondary indexes
  - Global secondary indexes
  
A local secondary index uses the same partition key as your tables primary key but a different sort key.
With global secondary index, you can choose any attributes you want for your partition key and your sort key.

Item Collection
An item collection refers to a group of items that share the same partition key in either the base table or a secondary index.
DynamoDB partitions your data across a number of nodes in a way that allows for consistent performance as you scale. However, all items with the same
partition key will be kept on the same storage node.

-------------------------------------------------------------------------------------------------------------------------------------------------------
DynamoDB Stream
A DynamoDB stream is an ordered flow of information about changes to items in a DynamoDB table. 
When you enable a stream on a table, DynamoDB captures information about every modification to data items in the table.
The combination of DynamoDB Streams with serverless compute with AWS Lambda gives you a fully-managed
system to react to database changes.

Time-to-live(TTL)
TTL's allow you to have DynamoDB automatically delete items on a per-item basis. This is a great option for storing short-term 
data in DynamoDB.

Partitions
Partitions are the core storage units underlying your DynamoDB table.
We noted before that DynamoDB is built for infinite scale, and it does that by sharding your data across multiple server
instances. Each item collection will be in a particular partition, and this will enable fast queries on multiple items.

Consistency
Each partition in DynamoDB is made up of 3 nodes.
1 primary node and 2 secondary nodes.
When you do a write operation
  - DynamoDB request router takes the partition key from the request
  - hashes the partition key and finds the right partition
  - writes to the primary node in the partition
  - responds to the client saying the wite operation is complete
  - asynchronously replicates the item from the primary to secondary nodes.
The reason for having secondary nodes
  - Provide fault-tolerance in case the primary node goes down
  - These secondary nodes can serve read requests to alleviate pressure on the primary node

** Problem **
Because writes are asynchronously replicated from the primary to secondary nodes, the secondary might be a little behind the primary node.

Two consistency options available with DynamoDB
  - Strong consistency: any item you read from DynamoDB will reflect all writes that occurred prior to the read being executed.
  - Eventual consistency(default): Its possible the item(s) you read will not reflect all prior writes.
  
There are two times you need to think about consistency with DynamoDB
  - Whenever you are reading data from the base table, you can choose your consistency level. By default its eventually-consistent read.
  - You should think about consistency when choosing your secondary index type. 

------------------------------------------------------------------------------------------------------------------------------------------------
DynamoDB Limits
  - Item size limits
    A single DynamoDB item is limited to 400KB of data.
  - Query and Scan request size limits
    Query and Scan, the two "fetch many" API actions will read a maximum of 1MB of data from your table.
  - Partition throughput limits
    A single partition can have a maximum of 3000 Read Capacity Units or 1000 Write Capacity Units.
    Thus you will need to be doing 3000 reads per second for a given partition key to hit these limits.
  - Item collection limits
    An item collection refers to all items with a given partition key. A single item collection cannot be larger than 10GB.
  
------------------------------------------------------------------------------------------------------------------------------------------------
Overloading Keys
One unique quirk of modeling with DynamoDB is that you will often include different types of entities in a single table.

              Primary Key                       Attributes
Partition Key: PK    Sort Key: SK         OrgName        Subscription Level
ORG#INFOSYS          ORG#INFOSYS          Infosys        Enterprise
                                          UserName       Role
ORG#INFOSYS          USER#ANTONY          Antony C       Employee
ORG#INFOSYS          USER#AASHISH         Aashish A      Employee

In the above table, we have 2 different types of entities, Users and Organisations.
Organisations and Users have a different set of attributes.
Look at the way the partition key and the sort key are maintained.
This concept of using generic names for your primary keys and using different values depending on the type of item is known as
overloading your keys.

================================================================================================================================================
DynamoDB API's

API's split into 3 categories
1: Item-based actions - operating on specific items
2: Queries - operating on an item collection
3: Scans - operating on the whole table

----------------------------------------------------------------------------------------------------------------------------------
Item-based actions
There are 4 core API actions for item-based actions
  - GetItem: used for reading a single item from a table
  - PutItem: used for writing an item to a table. This can completely overwrite an existing item with the same key, if any.
  - UpdateItem: used for updating an item in a table. This can create a new item if it doesn’t previously exist, or it can add,
                remove, or alter properties on an existing item.
  - DeleteItem: used for deleting an item from a table.
  
3 rules around item-based actions
  - Full primary key must be specified in your request
  - All actions to alter data - writes, updates or delete must use an item-based action.
  - All item-based actions must be performed on your main table, not a secondary index.

2 sub-categories of single-item API
  - Batch actions
  - Transaction actions
These categories are used for reading and writing multiple DynamoDB items in a single request. While these operate on
multiple items at once, I still classify them as item-based actions because you must specify the exact items on which you want to
operate.

Batch action: your reads or writes can succeed or fail independently. The failure of one write
              won’t affect the other writes in the batch.
Transaction action: all of your reads or writes will succeed or fail together. The failure of a single
                    write in your transaction will cause the other writes to be rolled back.
  
-----------------------------------------------------------------------------------------------------------------------------------
Query API

The Query API action lets you retrive multiple items with the same partition key.

A Query operation using the AWS JavaScript SDK

const inputParams = {
    TableName: "test_MoviesAndActors",
    KeyConditionExpression: "#actor = :actor AND #movie BETWEEN :a AND :m",
    ExpressionAttributeNames: {
      "#actor": "Actor",
      "#movie": "Movie",
    },
    ExpressionAttributeValues: marshall({
      ":actor": "Tom Hanks",
      ":a": "A",
      ":m": "M",
    }),
  };
  
const data = await dbClient.send(new QueryCommand(inputParams));

----------------------------------------------------------------------------------------------------------------------------------
Scan API
A Scan will grab everything in a table.
The times you may consider using the scan operation.
  - When you have a small table
  - When you're exporting all data from your table to a different system
  - In exceptional situations, where you have specifically modeled a sparse secondary index in a way that expects a scan.

DON'T USE SCANS
----------------------------------------------------------------------------------------------------------------------------------
How DynamoDB enforces efficiency?
DynamoDB uses partitions, or small storage nodes of about 10GB, to shard your data across multiple machines. The
sharding is done on the basis of the partition key. Thus, if the DynamoDB request router is given the partition key for an item, it
can do an O(1) lookup in a hash table to find the exact node or set of nodes where that item resides.
This is why all the single-item actions and the Query action require a partition key.

===================================================================================================================================
